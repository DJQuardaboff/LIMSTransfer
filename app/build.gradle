import com.android.build.gradle.internal.dsl.SigningConfig
import org.apache.commons.io.FilenameUtils

import java.nio.file.Paths

apply plugin: 'com.android.application'
apply from: 'plc_systems.gradle'
apply from: 'version.gradle'

def signingFilePath = 'signing.gradle'
def performSigning = file(signingFilePath).exists()
if (performSigning) {
    apply from: signingFilePath
}

private static int generateVersionCode(def version) {
    return (version.major * 10000) + (version.minor * 100) + version.patch
}

private static String generateVersionName(def version) {
    String versionName = "${version.major}.${version.minor}.${version.patch}"
    if (version.suffix != null) {
        versionName += "-" + version.suffix
    }
    return versionName
}

android {
    compileSdkVersion 29
    buildToolsVersion '29.0.1'
    defaultConfig {
        targetSdkVersion 29
        minSdkVersion 23
        versionCode generateVersionCode(plc_version)
        versionName generateVersionName(plc_version)
        //testInstrumentationRunner 'android.support.test.runner.AndroidJUnitRunner'
    }
    buildTypes {
        release {
            if (performSigning) {
                def signingConfig = new SigningConfig("release")
                        .setStoreFile(file(plc_signing.storeFilePath))
                        .setStorePassword(plc_signing.storePassword)
                        .setKeyAlias(plc_signing.keyAlias)
                        .setKeyPassword(plc_signing.keyPassword)
                signingConfig.setV1SigningEnabled(plc_signing.v1SigningEnabled)
                signingConfig.setV2SigningEnabled(plc_signing.v2SigningEnabled)
                setSigningConfig(signingConfig)
            } else {
                logger.log(LogLevel.WARN, 'No signing config found, release apks will not be signed')
            }
            //minifyEnabled false
            //proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
        debug {
            applicationIdSuffix '.debug'
            debuggable true
        }
    }
    flavorDimensions 'system', 'scannerSdk'
    productFlavors {
        janam {
            dimension 'scannerSdk'
        }
        zebra {
            dimension 'scannerSdk'
            targetSdkVersion 27
            minSdkVersion 23
        }
    }

    for (def system : plcSystems) {
        productFlavors.create(system.key, {
            dimension 'system'
            def systemSettings = system.value
            applicationId "com.porterlee.${system.key}.transfer"
            resValue 'string', 'app_name', "${systemSettings.name} Transfer"

            def valueFormatters = [
                    'boolean' : { value -> value ? 'true' : 'false' },
                    'String'  : { value -> value ? "\"${value}\"" : 'null' },
                    'String[]': { value -> value ? "{\"${value.join('", "')}\"}" : 'null' },
            ]

            for (def i : plcSystems) {
                buildConfigField 'boolean', "isSystem${i.key.capitalize()}", valueFormatters['boolean'](system.key == i.key)
            }

            def barcodeTypes = ['item', 'container', 'location']
            def barcodeTypeProperties = [
                    hasCustodyOf : [
                            type: 'boolean',
                    ],
                    hasLabCode   : [
                            type: 'boolean',
                    ],
                    base32Prefix : [
                            type: 'String',
                    ],
                    base64Prefix : [
                            type: 'String',
                    ],
                    otherPrefixes: [
                            type: 'String[]',
                    ],
            ]

            for (def BTName : barcodeTypes) {
                def BTValue = systemSettings.barcodeType[BTName]

                for (def BTProp : barcodeTypeProperties) {
                    def BTPropName = BTProp.key
                    def BTPropValue = BTValue[BTPropName]
                    def BTPropType = BTProp.value['type']
                    def BTPropValueFormatter = valueFormatters[BTPropType]
                    buildConfigField BTPropType, "barcodeType_${BTName}_${BTPropName}", BTPropValueFormatter(BTPropValue)
                }
            }

            def systemProperties = [
                    displayQuantity          : [
                            type: 'boolean',
                    ],
                    displayTransferNavigation: [
                            type: 'boolean',
                    ],
            ]

            for (def SProp : systemProperties) {
                def SPropName = SProp.key
                def SPropValue = systemSettings[SPropName]
                def SPropType = SProp.value['type']
                def SPropValueFormatter = valueFormatters[SPropType]
                buildConfigField SPropType, SPropName, SPropValueFormatter(SPropValue)
            }
        })
    }

    def publishAll = project.tasks.create("publishAll")
    def publishBuildTypes = new HashMap<String, Task>()
    buildTypes.each {
        buildType ->
            def taskName = "publish" + buildType.name.capitalize()
            publishBuildTypes.put(buildType.name, project.tasks.create(taskName))
    }
    applicationVariants.all {
        variant ->
            def inFile
            variant.outputs.all {
                variantOutput ->
                    inFile = variantOutput.outputFile
            }
            if (inFile != null) {
                def has_signingConfig = variant.signingConfig != null
                def outDir = Paths.get(buildDir.path, variant.buildType.name, variant.productFlavors[1].name, 'v' + variant.versionName).toString()
                String outName = plcSystems[variant.productFlavors[0].name].name + 'Transfer'
                if (variant.buildType.debuggable) outName += '-debug'
                if (!has_signingConfig) outName += '-unsigned'
                def task = project.tasks.create("publish${variant.name.capitalize()}") {
                    task ->
                        task.dependsOn variant.assembleProvider
                        task.doLast {
                            if (!has_signingConfig) {
                                logger.log(LogLevel.WARN, "Variant '${variant.name}' does not have a signingConfig, will be unsigned")
                            }
                            copy {
                                from inFile
                                into outDir
                                rename(FilenameUtils.getBaseName(inFile.name), outName)
                            }
                        }
                }
                publishAll.dependsOn task
                publishBuildTypes[variant.buildType.name].dependsOn task
            }
    }
}

dependencies {
    janamImplementation project(':janam_xt2_xt2-_xm75_xt100_xg200_sdk_v3-2-1')
    zebraCompileOnly 'com.symbol:emdk:7.0.0'

    implementation 'androidx.appcompat:appcompat:1.2.0'
    implementation 'androidx.recyclerview:recyclerview:1.1.0'
    implementation 'androidx.constraintlayout:constraintlayout:1.1.3'
    implementation 'commons-io:commons-io:2.6'
    implementation 'com.github.gcacace:signature-pad:1.2.1'
    implementation 'me.zhanghai.android.materialprogressbar:library:1.6.1'
    testImplementation 'junit:junit:4.13'
    androidTestImplementation 'androidx.test.ext:junit:1.1.1'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'
}
